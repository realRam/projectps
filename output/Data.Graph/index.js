// Generated by purs version 0.11.6
"use strict";
var Data_Bifunctor = require("../Data.Bifunctor");
var Data_Boolean = require("../Data.Boolean");
var Data_CatList = require("../Data.CatList");
var Data_Foldable = require("../Data.Foldable");
var Data_Functor = require("../Data.Functor");
var Data_List = require("../Data.List");
var Data_List_Types = require("../Data.List.Types");
var Data_Map = require("../Data.Map");
var Data_Maybe = require("../Data.Maybe");
var Data_Monoid = require("../Data.Monoid");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Tuple = require("../Data.Tuple");
var Prelude = require("../Prelude");
var Emit = (function () {
    function Emit(value0) {
        this.value0 = value0;
    };
    Emit.create = function (value0) {
        return new Emit(value0);
    };
    return Emit;
})();
var Visit = (function () {
    function Visit(value0) {
        this.value0 = value0;
    };
    Visit.create = function (value0) {
        return new Visit(value0);
    };
    return Visit;
})();
var Graph = function (x) {
    return x;
};
var vertices = function (v) {
    return Data_Functor.map(Data_List_Types.functorList)(Data_Tuple.fst)(Data_Map.values(v));
};
var unfoldGraph = function (dictOrd) {
    return function (dictFunctor) {
        return function (dictFoldable) {
            return function (dictFoldable1) {
                return function (ks) {
                    return function (label) {
                        return function (edges) {
                            return Data_Map.fromFoldable(dictOrd)(dictFoldable)(Data_Functor.map(dictFunctor)(function (k) {
                                return new Data_Tuple.Tuple(k, new Data_Tuple.Tuple(label(k), Data_List.fromFoldable(dictFoldable1)(edges(k))));
                            })(ks));
                        };
                    };
                };
            };
        };
    };
};
var topologicalSort = function (dictOrd) {
    return function (v) {
        var visit = function ($copy_state) {
            return function ($copy_stack) {
                var $tco_var_state = $copy_state;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(state, stack) {
                    var v1 = Data_CatList.uncons(stack);
                    if (v1 instanceof Data_Maybe.Nothing) {
                        $tco_done = true;
                        return state;
                    };
                    if (v1 instanceof Data_Maybe.Just && v1.value0.value0 instanceof Emit) {
                        var state$prime = {
                            result: new Data_List_Types.Cons(v1.value0.value0.value0, state.result), 
                            unvisited: state.unvisited
                        };
                        $tco_var_state = state$prime;
                        $copy_stack = v1.value0.value1;
                        return;
                    };
                    if (v1 instanceof Data_Maybe.Just && v1.value0.value0 instanceof Visit) {
                        if (Data_Map.member(dictOrd)(v1.value0.value0.value0)(state.unvisited)) {
                            var start = {
                                result: state.result, 
                                unvisited: Data_Map["delete"](dictOrd)(v1.value0.value0.value0)(state.unvisited)
                            };
                            var next = Data_Maybe.maybe(Data_Monoid.mempty(Data_List_Types.monoidList))(Data_Tuple.snd)(Data_Map.lookup(dictOrd)(v1.value0.value0.value0)(v));
                            $tco_var_state = start;
                            $copy_stack = Data_Semigroup.append(Data_CatList.semigroupCatList)(Data_CatList.fromFoldable(Data_List_Types.foldableList)(Data_Functor.map(Data_List_Types.functorList)(Visit.create)(next)))(Data_CatList.cons(new Emit(v1.value0.value0.value0))(v1.value0.value1));
                            return;
                        };
                        if (Data_Boolean.otherwise) {
                            $tco_var_state = state;
                            $copy_stack = v1.value0.value1;
                            return;
                        };
                    };
                    throw new Error("Failed pattern match at Data.Graph line 92, column 7 - line 110, column 40: " + [ v1.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_state, $copy_stack);
                };
                return $tco_result;
            };
        };
        var initialState = {
            unvisited: v, 
            result: Data_List_Types.Nil.value
        };
        var go = function ($copy_v1) {
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1) {
                var v2 = Data_Map.findMin(v1.unvisited);
                if (v2 instanceof Data_Maybe.Just) {
                    $copy_v1 = visit(v1)(Data_CatList.fromFoldable(Data_Foldable.foldableArray)([ new Visit(v2.value0.key) ]));
                    return;
                };
                if (v2 instanceof Data_Maybe.Nothing) {
                    $tco_done = true;
                    return v1.result;
                };
                throw new Error("Failed pattern match at Data.Graph line 86, column 7 - line 88, column 26: " + [ v2.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($copy_v1);
            };
            return $tco_result;
        };
        return go(initialState);
    };
};
var outEdges = function (dictOrd) {
    return function (k) {
        return function (v) {
            return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.snd)(Data_Map.lookup(dictOrd)(k)(v));
        };
    };
};
var lookup = function (dictOrd) {
    return function (k) {
        return function (v) {
            return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.fst)(Data_Map.lookup(dictOrd)(k)(v));
        };
    };
};
var functorGraph = new Data_Functor.Functor(function (f) {
    return function (v) {
        return Data_Functor.map(Data_Map.functorMap)(Data_Bifunctor.lmap(Data_Tuple.bifunctorTuple)(f))(v);
    };
});
var fromMap = Graph;
module.exports = {
    fromMap: fromMap, 
    lookup: lookup, 
    outEdges: outEdges, 
    topologicalSort: topologicalSort, 
    unfoldGraph: unfoldGraph, 
    vertices: vertices, 
    functorGraph: functorGraph
};
