// Generated by purs version 0.11.6
"use strict";
var Color = require("../Color");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Data_Foldable = require("../Data.Foldable");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Data_Int = require("../Data.Int");
var Data_List = require("../Data.List");
var Data_List_ThreeOrMore = require("../Data.List.ThreeOrMore");
var Data_List_Types = require("../Data.List.Types");
var Data_Monoid = require("../Data.Monoid");
var Data_NonEmpty = require("../Data.NonEmpty");
var Data_Ord = require("../Data.Ord");
var Data_Ring = require("../Data.Ring");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Semiring = require("../Data.Semiring");
var Graphics_Drawing = require("../Graphics.Drawing");
var Graphics_Isometric_Point = require("../Graphics.Isometric.Point");
var Graphics_Isometric_Types = require("../Graphics.Isometric.Types");
var $$Math = require("../Math");
var Prelude = require("../Prelude");
var Fill = (function () {
    function Fill(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Fill.create = function (value0) {
        return function (value1) {
            return new Fill(value0, value1);
        };
    };
    return Fill;
})();
var Many = (function () {
    function Many(value0) {
        this.value0 = value0;
    };
    Many.create = function (value0) {
        return new Many(value0);
    };
    return Many;
})();
var transform = function (t) {
    var go = function (v) {
        if (v instanceof Fill) {
            return new Fill(v.value0, Data_Functor.map(Data_List_Types.functorList)(Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(t))(v.value1));
        };
        if (v instanceof Many) {
            return new Many(Data_Functor.map(Data_List_Types.functorList)(transform(t))(v.value0));
        };
        throw new Error("Failed pattern match at Graphics.Isometric line 149, column 5 - line 149, column 57: " + [ v.constructor.name ]);
    };
    return go;
};
var translateX = function (dx) {
    return transform(Graphics_Isometric_Point.translateX(dx));
};
var translateY = function (dy) {
    return transform(Graphics_Isometric_Point.translateY(dy));
};
var translateZ = function (dz) {
    return transform(Graphics_Isometric_Point.translateZ(dz));
};
var semigroupScene = new Data_Semigroup.Semigroup(function (v) {
    return function (v1) {
        if (v instanceof Many) {
            return new Many(Data_Semigroup.append(Data_List_Types.semigroupList)(v.value0)(Data_List.singleton(v1)));
        };
        if (v1 instanceof Many) {
            return new Many(new Data_List_Types.Cons(v, v1.value0));
        };
        return new Many(new Data_List_Types.Cons(v, new Data_List_Types.Cons(v1, Data_List_Types.Nil.value)));
    };
});
var scale = function (factor) {
    return transform(Graphics_Isometric_Point.scale(factor));
};
var rotateZ = function (angle) {
    return transform(Graphics_Isometric_Point.rotateZ(angle));
};
var rotateY = function (angle) {
    return transform(Graphics_Isometric_Point.rotateY(angle));
};
var rotateX = function (angle) {
    return transform(Graphics_Isometric_Point.rotateX(angle));
};
var polygon = function (num) {
    return function (r) {
        var toPoint = function (j) {
            var phi = ((-2.0 * $$Math.pi) / Data_Int.toNumber(num)) * Data_Int.toNumber(j);
            return {
                x: r * $$Math.cos(phi), 
                y: r * $$Math.sin(phi)
            };
        };
        return Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(toPoint)(new Data_NonEmpty.NonEmpty(0, new Data_NonEmpty.NonEmpty(1, new Data_NonEmpty.NonEmpty(2, Data_List.range(3)(num - 1 | 0)))));
    };
};
var move = function (v) {
    return Data_Functor.map(Data_List_Types.functorList)(Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(Graphics_Isometric_Point.translate(v)));
};
var monoidScene = new Data_Monoid.Monoid(function () {
    return semigroupScene;
}, new Many(Data_Monoid.mempty(Data_List_Types.monoidList)));
var isometricAngle = $$Math.pi / 2.0 - $$Math.asin(1.0 / $$Math.sqrt(3.0));
var project = function (p) {
    var beta = $$Math.pi / 4.0;
    var rotated = Graphics_Isometric_Point.rotateX(isometricAngle)(Graphics_Isometric_Point.rotateZ(beta)(p));
    return {
        x: -rotated.x, 
        y: rotated.y
    };
};
var renderFace = function (dir) {
    return function (color) {
        return function (v) {
            var path = Graphics_Drawing.closed(Data_NonEmpty.foldableNonEmpty(Data_NonEmpty.foldableNonEmpty(Data_NonEmpty.foldableNonEmpty(Data_List_Types.foldableList))))(Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(project)(v));
            var normal = Graphics_Isometric_Point.normalize(Graphics_Isometric_Point.cross(Graphics_Isometric_Point.vector(v.value0)(v.value1.value0))(Graphics_Isometric_Point.vector(v.value0)(v.value1.value1.value0)));
            var amount = 0.2 * Graphics_Isometric_Point.dot(dir)(normal);
            var col = Color.lighten(amount)(color);
            return Graphics_Drawing.filled(Graphics_Drawing.fillColor(col))(path);
        };
    };
};
var filled = Fill.create;
var fillShape = function (dir) {
    return function (color) {
        return function (faces) {
            var totalDepth = function (face) {
                return Data_Foldable.sum(Data_NonEmpty.foldableNonEmpty(Data_NonEmpty.foldableNonEmpty(Data_NonEmpty.foldableNonEmpty(Data_List_Types.foldableList))))(Data_Semiring.semiringNumber)(Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(Graphics_Isometric_Point.depth)(face));
            };
            var sortedFaces = Data_List.sortBy(Data_Ord.comparing(Data_Ord.ordNumber)(totalDepth))(faces);
            return Data_Foldable.foldMap(Data_List_Types.foldableList)(Graphics_Drawing.monoidDrawing)(renderFace(dir)(color))(sortedFaces);
        };
    };
};
var renderScene = function (dir) {
    return function (scene) {
        var dir$prime = Graphics_Isometric_Point.normalize(dir);
        var go = function (v) {
            if (v instanceof Fill) {
                return fillShape(dir$prime)(v.value0)(v.value1);
            };
            if (v instanceof Many) {
                return Data_Foldable.foldMap(Data_List_Types.foldableList)(Graphics_Drawing.monoidDrawing)(go)(v.value0);
            };
            throw new Error("Failed pattern match at Graphics.Isometric line 212, column 9 - line 212, column 59: " + [ v.constructor.name ]);
        };
        return go(scene);
    };
};
var extrudeCone = function (path2D) {
    return function (height) {
        var tip = {
            x: 0.0, 
            y: 0.0, 
            z: height
        };
        var side = function (p1) {
            return function (p2) {
                return new Data_NonEmpty.NonEmpty(p1, new Data_NonEmpty.NonEmpty(p2, new Data_NonEmpty.NonEmpty(tip, Data_List_Types.Nil.value)));
            };
        };
        var path = Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(Graphics_Isometric_Point.from2D)(path2D);
        var sides = Data_List.zipWith(side)(Data_List_ThreeOrMore.toList(path))(new Data_List_Types.Cons(Data_List_ThreeOrMore.last(path), Data_List_ThreeOrMore.toList(path)));
        return new Data_List_Types.Cons(path, sides);
    };
};
var extrude = function (path2D) {
    return function (height) {
        var raise = Graphics_Isometric_Point.translateZ(height);
        var side = function (p1) {
            return function (p2) {
                return new Data_NonEmpty.NonEmpty(p1, new Data_NonEmpty.NonEmpty(p2, new Data_NonEmpty.NonEmpty(raise(p2), new Data_List_Types.Cons(raise(p1), Data_List_Types.Nil.value))));
            };
        };
        var path = Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(Graphics_Isometric_Point.from2D)(path2D);
        var sides = Data_List.zipWith(side)(Data_List_ThreeOrMore.toList(path))(new Data_List_Types.Cons(Data_List_ThreeOrMore.last(path), Data_List_ThreeOrMore.toList(path)));
        var top = Data_Functor.map(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_NonEmpty.functorNonEmpty(Data_List_Types.functorList))))(raise)(path);
        return new Data_List_Types.Cons(path, new Data_List_Types.Cons(Data_List_ThreeOrMore.reverse(top), sides));
    };
};
var prism = function (p) {
    return function (dx) {
        return function (dy) {
            return function (dz) {
                var rectangle = new Data_NonEmpty.NonEmpty({
                    x: 0.0, 
                    y: 0.0
                }, new Data_NonEmpty.NonEmpty({
                    x: 0.0, 
                    y: dy
                }, new Data_NonEmpty.NonEmpty({
                    x: dx, 
                    y: dy
                }, new Data_List_Types.Cons({
                    x: dx, 
                    y: 0.0
                }, Data_List_Types.Nil.value))));
                return move(p)(extrude(rectangle)(dz));
            };
        };
    };
};
var cylinder = function (p) {
    return function (num) {
        return function (r) {
            return function (height) {
                return move(p)(extrude(polygon(num)(r))(height));
            };
        };
    };
};
var cube = function (p) {
    return function (dl) {
        return prism(p)(dl)(dl)(dl);
    };
};
var cone = function (p) {
    return function (num) {
        return function (r) {
            return function (height) {
                return move(p)(extrudeCone(polygon(num)(r))(height));
            };
        };
    };
};
var pyramid = function (p) {
    return cone(p)(4);
};
var pyramid3 = function (p) {
    return function (len) {
        return cone(p)(3)((len * $$Math.sqrt(3.0)) / 3.0);
    };
};
module.exports = {
    Fill: Fill, 
    Many: Many, 
    cone: cone, 
    cube: cube, 
    cylinder: cylinder, 
    extrude: extrude, 
    extrudeCone: extrudeCone, 
    filled: filled, 
    prism: prism, 
    pyramid: pyramid, 
    pyramid3: pyramid3, 
    renderScene: renderScene, 
    rotateX: rotateX, 
    rotateY: rotateY, 
    rotateZ: rotateZ, 
    scale: scale, 
    translateX: translateX, 
    translateY: translateY, 
    translateZ: translateZ, 
    semigroupScene: semigroupScene, 
    monoidScene: monoidScene
};
